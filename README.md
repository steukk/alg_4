*Работа Штойк Валерии* 

## Вариант 2

**Жадный алгоритм для составления расписания**

**Задача**: реализовать жадный алгоритм для распределения работ на машины с минимизацией
времени завершения (makespan).
(файл с кодом code.py)
**Алгоритм:**
- machine_loads = [0] * machines - создаем массив из нулей размером machines для хранения текущей загрузки каждой машины
- sorted_jobs = sorted(jobs, reverse=True) - сортируем работы по убыванию длительности (стратегия "самые тяжелые работы сначала")
- for job in sorted_jobs: - для каждой работы в отсортированном списке (от самой длинной к самой короткой):
- min_load_index = machine_loads.index(min(machine_loads)) - находим индекс машины с минимальной текущей загрузкой
- machine_loads[min_load_index] += job - добавляем текущую работу к загрузке выбранной машины
- return machine_loads, max(machine_loads) - возвращаем итоговое распределение работ и максимальное время завершения

**Временная сложность: O(n log n + n × m)**

Почему такая сложность: Сортировка n работ занимает O(n log n), а распределение каждой работы на машину с минимальной загрузкой требует O(m) операций для каждой из n работ.


## Задание 2: (контрольные задания)  Метод ближайшего соседа (TSP)
(файл с кодом code.java)
Как работает алгоритм:
- for (int i = 0; i < dist.length - 1; i++) - цикл по всем городам кроме начального (n-1 переход)
- int next = -1; int minDist = Integer.MAX_VALUE; - инициализация переменных для поиска минимума
- for (int j = 0; j < dist.length; j++) - перебор всех городов для поиска ближайшего
- if (!visited[j] && dist[curr][j] < minDist && dist[curr][j] > 0) - проверка: город не посещен, расстояние меньше минимума и существует связь
- minDist = dist[curr][j]; next = j; - обновление минимального расстояния и следующего города
- curr = next; path.add(curr); visited[curr] = true; - переход к найденному городу и добавление в маршрут

**Временная сложность:** O(n²) - для каждого из n городов проверяем n соседей.

## Контрольный вопрос 2: 

**Коэффициент аппроксимации α для задачи минимизации**

Коэффициент аппрокросимации α (α ≥ 1) — это величина, которая показывает, во сколько раз решение, найденное приближенным алгоритмом, может быть хуже оптимального решения в худшем случае.

Формально: для любого входа I выполняется A(I) ≤ α × OPT(I), где A(I) — значение, найденное алгоритмом, а OPT(I) — оптимальное значение.

Коэффициент α характеризует гарантированное качество приближенного алгоритма. Чем ближе α к 1, тем лучше алгоритм. Например, если α = 2, то алгоритм гарантированно находит решение не более чем в 2 раза хуже оптимального для любых входных данных.
